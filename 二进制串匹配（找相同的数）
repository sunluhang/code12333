给定两个二进制串A和B，只有“0”和“1”组成。现在的任务是求出串A在串B中出现多少次？

例如，串B是“1001110110”而串A为“11”，你应该输出3。

Input
第一行为一个整数n，表示下面有n组样例。在每一组样例中有两行，第一行给出了二进制串A，A长度不超过10，第二行给出了二进制串B，B的长度不超过1000。并且保证B总是长于A。

Output
 对于每一组输入，输出一行包含一个整数，表示A在B中出现的次数。

Sample Input
3
11
1001110110
101
110010010010001
1010
110100010101011 
Sample Output
3
0
3

#include <stdio.h>
#include <string.h>
int main(){
    char A[11];
    char B[1001];
    int n;
    scanf("%d",&n);
    while(n--){
        scanf("%s",A);
        scanf("%s",B);
        int lenA = strlen(A);   
        int lenB = strlen(B);
        int count = 0;
        for(int i = 0; i <= lenB - lenA; i++){
            int match = 1;
            for(int j = 0; j < lenA; j++){
                if(B[i + j] != A[j]){
                    match = 0;
                    break;
                }
            }
            if(match){
                count++;
            }}printf("%d\n",count);
        }
        return 0;

                
            
            

    }





    int len是读取字符串长度；
    for(int i=0;i+lenA<=lenB;i++){
        int march=1;
        for(int j= 1;j<lenA;j++){
        if(B[i+j]!=A[j]){
        march = 0;
        break;
        }
      }
      if(march)
      count++;}}
      A = "11"，B = "1001110110"

lenA=2，lenB=10

外层循环 i从 0 到 8：

i=0 → 子串 "10"≠ "11"→ 不匹配

i=1 → 子串 "00"≠ "11"→ 不匹配

i=2 → 子串 "01"≠ "11"→ 不匹配

i=3 → 子串 "11"= "11"→ 匹配，count=1

i=4 → 子串 "11"= "11"→ 匹配，count=2

i=5 → 子串 "10"≠ "11"→ 不匹配
