int* pa;
pa=&a;
printf("%d",*pa);
char cha='A';
char* pha==&cha;
printf("%d".sizeof(cha));
首地址就是地址名；
//int i,*pa,a[11]={0,1,2,3,4,5,6,7,8,9};
pa=a;
for(int i=0;i<10;i++)
{
    printf("%d",pa[i]);}




\\int My_strlen(char* p)等价于(char p[])
{char* ps=s;
while(*p!='0\n'){p++};
}
inr main(){
char s[101];
gets(s);
int len=My_strlen(s);
printf("%d",len);
}









int a=5,b=9;
swap(a,b);//交换a,b;





&右边必须是明确的地址，不能是(a+b)形式；


访问那个地址上的变量；
*是一个单目运算符，用来访问指针的值所表示的地址上的变量；
可以做右值也可以做左值；
int k =*p;
*p = k +1;


指针应用场景二：
函数返回多个值，某些值就只能通过指针返回；
传入的参数实际上是需要保存带回的结果的变量；





void minmax(int a[],int len, int *max,int *min);
int main(void)
{ int a[] = {1,2,3,4,5,6,7,8,9,11,55};
int min,max;
minmax(a,sizeof(a)/sizeof(a[0]),&min,&max);
printf("min=%d,max=%d\n",min,max);
return 0;
}
void minmax(int a[],int len,int *min,int *max)
{
      int i;
      *min =*max =a[0];
      for(i=1;i<len;i++){
         if(a[i]<*min){
         *min=a[i];}
         if(a[i]>*max){
         *max=a[i];
}
}
}



指针应用场景二；
函数返回运算的状态，结果通过指针返回；
常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错；
    -1或0；
但是当任何数值都是有效的可能结果时，就得分开返回了



常见错误：定义了指针变量，还没有指向任何变量，就开始使用指针；



注：
函数参数表中的数组实际上是指针：
sizeof(a)==sizeof(int*)
但是可以用数组的运算符[]进行计算


const:
int i;
congst int* p1 = &i;
int const* p2 = &i;
int *const p3 = &i;
判断哪个被const了的标志是const在*的前面还是后面




指针计算：
可以对指针进行：
加减，递增递减++ -- 两个指针相减

*p++:
取出p所指的那个数据来，完事之后顺便把p移到下一个位置去；
*的优先级虽然高但是没有++高；（先用再加）
<，<=，==，>，>=，！=对于指针都可以做
比较它们在内存中的地址


用指针来做什么：
需要传入较大的数据时用作参数；
传入数组后对数组做操作；
函数返回不止一个结果；
需要用函数来修改不止一个变量；
动态申请内存：
