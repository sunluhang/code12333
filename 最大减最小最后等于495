任选一个数字不全相同的三位正整数，把所有的数字从大到小排列，再把所有的数字从小到大排列，用前者减去后者得到一个新的数。重复对新得到的数进行上述操作，最终在有限的步骤之内必定会得到495。

例如，选择三位数字182，经过如下3步运算之后得到495：

                                                                    821-128=693

                                                                    963-369=594

                                                                    954-459=495

Input
输入一个三位的正整数，三位数字不全相同。

Output
输出多行。首先按行输出每一步的计算过程（数字和运算符之间不需要空格分隔），最后一行输出得到495所需的步骤数。如果操作数的高位是0（最高位是0，或最高位、次高位同时为0时），则不输出高位。

Sample Input
182
Sample Output
821-128=693
963-369=594
954-459=495
3






#include <stdio.h>//不需要math函数

int main() {
    int num;
    scanf("%d", &num);
    int steps = 0;
    
    while (num != 495) {
        int a = num / 100;
        int b = (num / 10) % 10;
        int c = num % 10;
        
        // 手动排序三个数字
        int max, mid, min;
        if (a >= b && a >= c) {
            max = a;
            if (b >= c) { mid = b; min = c; }
            else { mid = c; min = b; }
        } else if (b >= a && b >= c) {
            max = b;
            if (a >= c) { mid = a; min = c; }
            else { mid = c; min = a; }
        } else {
            max = c;
            if (a >= b) { mid = a; min = b; }
            else { mid = b; min = a; }
        }
        
        int max_num = max * 100 + mid * 10 + min;
        int min_num = min * 100 + mid * 10 + max;
        num = max_num - min_num;
        steps++;
        printf("%d-%d=%d\n", max_num, min_num, num);
    }
    
    printf("%d\n", steps);
    return 0;
}

//注意大括号的范围逻辑
